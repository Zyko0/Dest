//go:build ignore

package main

import (
	"bytes"
	"encoding/csv"
	"log"
	"os"
	"sort"
	"strconv"
	"strings"

	_ "embed"

	"github.com/dave/jennifer/jen"
)

const (
	ItemSpriteSize   = 128
	ItemSheetColumns = 7
)

var (
	//go:embed defs/items.csv
	itemsCSV string
)

func varName(name string) string {
	return strings.ReplaceAll(strings.TrimSpace(name), " ", "_")
}

func rarityName(rarity int64) string {
	switch rarity {
	case 0:
		return "Common"
	case 1:
		return "Uncommon"
	case 2:
		return "Rare"
	case 3:
		return "Epic"
	case 4:
		return "Legendary"
	case 5:
		return "Cursed"
	case 6:
		return "Dynamic"
	default:
		panic("unexpected rarity value")
	}
}

func handName(hand int64) string {
	switch hand {
	case 0:
		return "SingleHand"
	case 1:
		return "BothHands"
	case 2:
		return "None"
	default:
		panic("unexpected hand value")
	}
}

func main() {
	records, err := csv.NewReader(bytes.NewReader([]byte(itemsCSV))).ReadAll()
	if err != nil {
		log.Fatal("err: ", err)
	}

	type item struct {
		id          int64
		kind        int64
		hand        int64
		name        string
		description string
		maxStacks   int64
	}
	var items []*item
	for i, l := range records[1:] {
		var (
			id          int64
			kind        int64
			hand        int64
			name        string
			description string
			maxStacks   int64
		)

		if len(l) != 6 {
			log.Fatalf("err at line %d: expected 6 columns but %d", i, len(l))
		}
		if id, err = strconv.ParseInt(l[0], 10, 64); err != nil {
			log.Fatal("err: parsing id: ", err)
		}
		if kind, err = strconv.ParseInt(l[1], 10, 64); err != nil {
			log.Fatal("err: parsing kind: ", err)
		}
		if hand, err = strconv.ParseInt(l[2], 10, 64); err != nil {
			log.Fatal("err: parsing hand: ", err)
		}
		name, description = l[3], l[4]
		if maxStacks, err = strconv.ParseInt(l[5], 10, 64); err != nil {
			log.Fatal("err: parsing max stacks: ", err)
		}
		_, _, _, _, _ = id, kind, hand, description, maxStacks
		//fmt.Println("i:", i, "name:", name)
		items = append(items, &item{
			id:          id,
			kind:        kind,
			hand:        hand,
			name:        name,
			description: description,
			maxStacks:   maxStacks,
		})
	}

	sort.SliceStable(items, func(i, j int) bool {
		return items[i].id < items[j].id
	})
	// Generation
	f := jen.NewFile("building")
	f.HeaderComment("Code generated by go generate (gen_specs.go). DO NOT EDIT.")
	// Id consts
	f.Const().DefsFunc(func(g *jen.Group) {
		g.Id(varName(items[0].name)).Int().Op("=").Iota()
		for _, i := range items[1:] {
			g.Id(varName(i.name))
		}
		g.Id(varName("ItemMax"))
	})
	// Items
	f.Var().DefsFunc(func(g *jen.Group) {
		// Item definitions
		g.Id("impls").Op("=").Index(jen.Id("ItemMax")).Id("*Definition").ValuesFunc(func(gg *jen.Group) {
			for _, i := range items {
				stacks := jen.Lit(int(i.maxStacks))
				if i.maxStacks == -1 {
					stacks = jen.Id("InfiniteStacks")
				}
				gg.Line().Id(varName(i.name)).Op(":").Values(
					jen.Line().Id("ID").Op(":").Lit(int(i.id)),
					jen.Line().Id("Kind").Op(":").Id(rarityName(i.kind)),
					jen.Line().Id("Hand").Op(":").Id(handName(i.hand)),
					jen.Line().Id("Name").Op(":").Lit(i.name),
					jen.Line().Id("Description").Op(":").Lit(i.description),
					jen.Line().Id("MaxStacks").Op(":").Add(stacks),
					jen.Line().Id("Rect").Op(":").Add(
						jen.Qual("image", "Rect").Call(
							jen.Lit(int(i.id%ItemSheetColumns)*ItemSpriteSize),
							jen.Lit(int(i.id/ItemSheetColumns)*ItemSpriteSize),
							jen.Lit(int(i.id%ItemSheetColumns+1)*ItemSpriteSize),
							jen.Lit(int(i.id/ItemSheetColumns+1)*ItemSpriteSize),
						),
					),
					jen.Line(),
				)
			}
		})
		// Items by kind
		g.Line()
		for i, k := range []string{"commons", "uncommons", "rares", "epics", "legendaries", "curses"} {
			g.Id(k).Op("=").Index(jen.Empty()).Id("int").ValuesFunc(func(gg *jen.Group) {
				for _, item := range items {
					if int(item.kind) == i {
						gg.Lit(int(item.id))
					}
				}
			})
		}
	})
	// Generated file
	if err = os.WriteFile("item_defs.go", []byte(f.GoString()), 0666); err != nil {
		log.Fatal("err: couldn't write file: ", err)
	}
}
